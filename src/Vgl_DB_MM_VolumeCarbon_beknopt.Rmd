---
title: "Volume, biomassa en koolstofgehalte volgens FRL en INBO-advies A.3104 (methode 4b)"
author: "Anja Leyman, Leen Govaere"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: FALSE
      smooth_scroll: FALSE

---

```{r Rm, eval = FALSE}
rm(list = ls())
```


```{r Setup, include = FALSE}

library(knitr)
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 9,
  fig.align = TRUE
)

library(MASS)
library(tidyverse)
library(RODBC)
library(here)
library(DT)
library(openssl)
library(lme4)
# library(WeMix)

run <- "run_LG"

# source(here::here('Scripts/bestandsnamen_invoergegevens.R'))
source(here::here("src/VBI_Functies.R"))
source(here::here("src/VBI3_Functies.R"))

afgewerkt <- c(0) # VBI1 en VBI2; alsof er nog geen reeksen van VBI3 afgewerkt zijn
# afgewerkt <- c(1,2) # reeksen 1 en 2 afgewerkt; wijzigt jaarlijks! - nu enkel focussen op VBI1 en VBI2
source(here::here("src/VBI3_constanten.R"))
```


# Vraagstelling

**Vraag ivm gebruik van mixed models versus design based bij de dataverwerking van de VBI**

Bij welk soort meetvragen is gebruik van MM wel of niet aangeraden? 

Ik dacht steeds voor toestand design-based en voor verschillen mixed models, omdat dan de BI's smaller zijn door rekening te houden met de gepaarde plots.

In het analyserapport lees ik *"Een design-based analyse is geschikt voor het bepalen van een toestand voor een bepaalde periode, maar minder geschikt voor het bepalen van een verschil tussen periodes omdat het moeilijk kan omgaan met de (gedeeltelijk) gepaarde plots.
Daarom raden we mixed models (§7.2.5) aan voor analyseren van verschillen of trends."*

Meer concreet vroegen we ons af hoe jij (jullie bij BMK) een inschatting zouden maken van de aangroei van de houtvoorraad of van de carbon stock over gans Vlaanderen? 

Mbv design-based berekeningen, of mbv mixed-models?

In het INBO-advies (INBO.A.3844) over berekening van totaal volume hout per boomsoort (ikv LULUCF) werd design-based gewerkt. 

Idem dito in het advies over carbon stock change (INBO.A.4103) dat Luc en ik (Anja) schreven (samen met Suzanne en Bruno). 

# Methodiek

## Algemeen

Dit script is een beknopte versie van een script dat volume, biomassa en koolstofgehalte berekent volgens FRL en INBO-advies A.3104 (methode 4b).

Onderstaand script berekent **biomassa** en **koolstofgehalte (C)** volgens methode 4b uit het advies.
Bijkomend worden ook **stamvolume**, **stompvolume** en **totaal volume** (die de basis vormen van de biomassa-berekeningen) expliciet berekend.
Deze methode wordt gebruikt door ULG (Sébastien Bauwens) en voor de aanmaak van de FRL (Forest Reference Level).
Ook de VMM heeft na het INBO-advies beslist om deze methode te hanteren in het kader van de LULUCF-rapporteringen.

Conform het hoger vermeld advies worden **alle plots met verjonging en/of bomen > 7 cm dbh** bij de analyse betrokken. 
Of met andere woorden, alle plots waar een soort aan gekoppeld kan worden.
Dus zonder kaalslagen of tijdelijke open ruimtes.
Het advies INBO A.3104 heeft zich hiervoor dan weer gebaseerd op het INBO-advies A.3844 mbt volume hout in bossen in Vlaanderen. Ook daar worden enkel deze plots bij de analyse betrokken.


## Berekeningen

**Algemeen**

$$\ C = \ V *  BEF * WD * \left(\ 1 + R \right) * FC$$

met 

- C = carbon stock (tC/ha)
- V = stamvolume > 7 cm (m³/ha)
- BEF = branch/biomass expansion factor: om het totale bovengrondse houtvolume (inclusief zwaar en dun kroonhout) te berekenen, vertrekkende van het stamvolume (diameter > 7 cm) 
- WD = wood density: om van volume naar biomassa over te gaan (t/m³)
- FC = carbon factor: ton C/ton droge biomassa (= 0.5)
- R = verhouding ondergrondse biomassa tov bovengrondse biomassa

<br>

**Concreet**

In onderstaand script gebruiken we de berekeningswijze voor biomassa conform de FRL: 

- BEF/VEF van Longuetaud: dit zijn variabele BEF's (afh. van diameter en hoogte)
- factoren cfr. FRL (R, FC, WD)
    - FC = 0.5

<br>
De factoren van Longuetaud zijn niet enkel boomsoort-afhankelijk, maar worden mede bepaald door diameter en hoogte van de boom.
Bijgevolg zijn we verplicht te vertrekken van individuele boommetingen (*tbl0Boom*).

<br>

# Referentie

Note technique version 20/11/2017. Estimation du volume et biomasse de différents compartiments de l’arbre. 
Accompagnement scientifique de l’IPRFW. Uliège - Wallonie environnement SPW.

<br>


# Invoer gegevens

Om het script wat behapbaar te houden, vetrekken we van data op boomniveau, met volume, biomassa en carbon reeds berekend.
(even getwijfeld om enkel de analyseset (plotniveau) aan te leveren, maar misschien beter dat je een breder zicht op de analyse hebt)

Naast boomgegevens hebben we ook info nodig over plots zonder bomen met diameter > 7 cm (plots waar StemVolume_m3_ha = 0).


```{r load_data, results='hide'}
load(here::here("data/data_boomniveau.RData"))

# individuele boommetingen met reeds berekend volume en biomassa
names(trees_living5)
dim(trees_living5)
table(trees_living5$Periode)

# plots zonder volume/biomassa
names(analyseSet_0_biomassa)
dim(analyseSet_0_biomassa)
table(analyseSet_0_biomassa$Periode)

# tbl_PlotDetailsbevat info over gekoppelde plots (belangrijk voor mixed models)
names(tbl_PlotDetails)
dim(tbl_PlotDetails)
table(tbl_PlotDetails$Periode)
```

# Aanmaak analyseset (plotniveau)

We zijn vertrokken van `tbl0Boom` (uit analysedb) => bosoppervlakte van de bosplot in rekening brengen mbv Fext_ha

- A4-bomen: Fext_ha = 10.000/AreaA4_m2_Plot
- A3-bomen: Fext_ha = 10.000/AreaA3_m2_Plot

AreaA4_m2/AreaA3_m2 is oppervlakte op segmentniveau, maar daar maken we hier geen gebruik van, omdat we hier onmiddelijk alles op plotniveau berekenen. 


```{r plotniveau, results = 'hide'}
colnames(trees_living5)
analyseSet <- trees_living5 %>%
  dplyr::group_by(IDPlots, Periode, PlotWeight, DateDendro, REEKS) %>%
  dplyr::summarise(
    CheckVolumeTotaal = sum(Volume_m3 * Fext_Ha, na.rm = TRUE),
    StemVolume_m3_ha = sum(StemVolume_m3 * Fext_Ha, na.rm = TRUE), # met correctie voor dunne boompjes met volume Dagnelie = 0 (zie chunck "volume_cilinder_afgeknotte_kegel")
    StemVolume_m3_ha_v4 = sum(StemVolume_m3_v4 * Fext_Ha, na.rm = TRUE), # cfr Dagnelie/Quataert (repo v4)
    VolumeStump_m3_ha = sum(VolumeStump_m3 * Fext_Ha, na.rm = TRUE),
    TotalVolumeVEF_m3_ha = sum(TotalVolume_m3 * Fext_Ha, na.rm = TRUE),
    Biomass_t_ha = sum(TotalBiomass_t * Fext_Ha, na.rm = TRUE),
    Carbon_t_ha = sum(TotalCarbon_t * Fext_Ha, na.rm = TRUE),
    # test = StemVolume_m3_ha - StemVolume_m3_ha_v4,
    # test_proc = 100*test /StemVolume_m3_ha_v4
  ) %>%
  dplyr::ungroup() %>%
  dplyr::rename(
    Year = DateDendro,
    Weight = PlotWeight, Reeks = REEKS
  )

# summary(trees_living5)
```


```{r add_bosplots_without_volume_obvtbl10, results='hide'}
analyseSet2 <- rbind(analyseSet, analyseSet_0_biomassa)
nrow(analyseSet) + nrow(analyseSet_0_biomassa) - nrow(analyseSet2)

analyseSet <- analyseSet2 %>%
  select(-CheckVolumeTotaal, -StemVolume_m3_ha_v4, -VolumeStump_m3_ha, -TotalVolumeVEF_m3_ha)

names(analyseSet)
```


# Selectie periode

Tot hier werden er volumes etc per boom/plot berekend, ongeacht de periode of reeks waarin de opname is gebeurd.
Voor rapportering willen we een voortschrijdend gemiddelde gaan berekenen, over de plots die gedurende de laatste tien jaar zijn gemeten. Een aantal reeksen van die plots zijn 10 jaar eerder gemeten, een voorlopig nog groter aantal is gemiddeld 15 jaar geleden gemeten.
Om makkelijk de desbetreffende plots/reeksen te selecteren maken we gebruik van de functie `get_last_20y`.

Voor het gemak zou ik voorstellen om nu even te focussen op VBI1 en VBI2, zonder rekening te houden met VBI3.
Daarvoor kiezen we in onderstaande chunck voor `afgewerkt <- c(0)`

Eenzelfde discrepantie tss design based en mixed models (zie verder) zien we wanneer we de reeds afgewerkte 2 reeksen van VBI3 bij de analyse betrekken `afgewerkt <- c(1,2)`.


```{r KiesPeriode}
afgewerkt <- c(0) # 10 reeksen VBI1 en 10 reeksen VBI2
# afgewerkt <- c(1,2) #20% van VBI3 is afgewerkt
source(here::here("src/VBI3_constanten.R"))
```


## analyseset met data van 10 opgemeten reeksen 

```{r analyseSet_GekozenPeriode, results='hide'}
analyseSet <- get_last_20y(Data = analyseSet2, Afgewerkt = afgewerkt) %>%
  as_tibble()
table(analyseSet$Periode)
table(analyseSet$VBI)
```


# Statistieken

## Design based

De functie `My.WgtParEstimation` berekent een gewogen gemiddelde en gewogen variantie.
Met deze variantie wordt een 95% betrouwbaarheidsinterval geconstrueerd gebaseerd  op een normale verdeling.
De weging is hier een variabele die aangeeft of een proefvlakcirkel al dan niet volledig in bos gelegen is.
Deze weging is dus geen survey-gewicht (omgekeerde van inclusiekans).

De gebruikte formules zijn equivalent met deze van een enkelvoudige aselecte steekproef.
De VBI is echter een systematische steekproef waarbij een grid van 0.5 km x 1 km met een random start over Vlaanderen gelegd is.
De variantie van een systematische steekproef met random start is kleiner dan de variantie van een enkelvoudige aselecte steekproef indien we kunnen verwachten dat er autocorrelatie in het kenmerk dat we willen inschatten.
Dit betekent dat de betrouwbaarheidsintervallen meer dan waarschijnlijk breder zijn dan nodig.


```{r statistics_per_periode, results = 'hide'}
colnames(analyseSet)
variables_for_statistics <- c("StemVolume_m3_ha", "VolumeStump_m3_ha", "TotalVolumeVEF_m3_ha", "Biomass_t_ha", "Carbon_t_ha")

p1 <- My.WgtParEstimation(
  analyseSet,
  VariableName = variables_for_statistics,
  Periode = 1)
p2 <- My.WgtParEstimation(
  analyseSet,
  VariableName = variables_for_statistics,
  Periode = 2)

Resultaat <- rbind(p1, p2)
colnames(Resultaat)
Resultaat[10:14] <- round(Resultaat[10:14], 3)
Resultaat

vars <- c("periode", "minYear", "maxYear", "minReeks", "maxReeks")

Resultaat <- Resultaat %>%
  mutate_at(vars, factor)

result_db <- Resultaat # design-based
```




## Model based analyse met lmer

```{r }
df20 <- analyseSet %>%
  inner_join(tbl_PlotDetails, by = c("IDPlots", c("VBI" = "Periode"))) %>% # IDGroup
  filter(!is.na(IDGroup))
```

### Aanmaak modellen stemvolume

```{r lmer_verschil}
Model.lmer_20 <- lmer(
  formula = StemVolume_m3_ha ~ fPeriode + (1 | IDGroup),
  data = df20,
  weights = Weight)
Model.lmer_20_noweight <- lmer(
  formula = StemVolume_m3_ha ~ fPeriode + (1 | IDGroup),
  data = df20)

summary(Model.lmer_20)
summary(Model.lmer_20_noweight)
plot(Model.lmer_20)

df20$E <- resid(Model.lmer_20)
qqnorm(df20$E)
ggplot(df20, aes(x = fPeriode, y = E)) +
  geom_boxplot()

df20 %>%
  group_by(IDGroup) %>%
  mutate(gepaard = ifelse(n() == 2, "1 en 2", as.character(Periode))) %>%
  ggplot() +
  geom_point(aes(x = fitted(Model.lmer_20), 
                 y = resid(Model.lmer_20),
                 colour = gepaard,
                 shape = gepaard),
             alpha = 0.3) +
  geom_smooth(aes(x = fitted(Model.lmer_20), 
                 y = resid(Model.lmer_20))) +
  geom_hline(yintercept = 0)

ggplot(df20, aes(x = IDGroup, y = E, colour = fPeriode, group = IDGroup)) +
  geom_point() +
  geom_line() +
  labs(y = "Residual", x = "IDGepaard")

print(get_lmer_output(Model = Model.lmer_20))
```

```{r lmer_nulmodel}
# nulmodel, nodig om toestand (vs verschil) te berekenen/weg te schrijven naar db
Model.lmer_20_0 <- lmer(StemVolume_m3_ha ~ 0 + fPeriode + (1 | IDGroup),
  data = df20,
  weights = Weight
)
summary(Model.lmer_20_0)
plot(Model.lmer_20_0)

df20$E <- resid(Model.lmer_20_0)
qqnorm(df20$E)
ggplot(df20, aes(x = fPeriode, y = E)) +
  geom_boxplot()

ggplot(df20, aes(x = IDGroup, y = E, colour = fPeriode, group = IDGroup)) +
  geom_point() +
  geom_line() +
  labs(y = "Residual", x = "IDGepaard")

print(get_lmer_output(Model = Model.lmer_20_0))
```

`Model.lmer_20` en `Model.lmer_20_0` schatten exact hetzelfde model, alleen is de parametrisatie verschillend.
In het tweede geval is er geen intercept gefit, waardoor onmiddellijk de predicties voor periode 1 en 2 uit de parameterschattingen af te lezen zijn.
In het eerste geval wordt wel een intercept gefit, waardoor de intercept overeenkomt met periode 1 en de schatting voor periode 2 het verschil geeft ten opzichte van periode 1.

Het gaat hier om lineaire mixed models.
Voor de responsvariabele wordt dus een Gaussiaanse verdeling aangenomen.
De gepaardheid van de proefvlakcirkels wordt in rekening gebracht door het random intercept.

De proefvlakgewichten worden via het `weights` argument van `lmer()` doorgegeven aan het model.
Dit argument wordt als volgt beschreven:

> an optional vector of ‘prior weights’ to be used in the fitting process. Should be NULL or a numeric vector. Prior weights are not normalized or standardized in any way. In particular, the diagonal of the residual covariance matrix is the squared residual standard deviation parameter sigma times the vector of inverse weights. Therefore, if the weights have relatively large magnitudes, then in order to compensate, the sigma parameter will also need to have a relatively large magnitude.

Deze definitie van `weights` is dus anders dan hoe de gewichten gebruikt werden in de design-based formules.

### Schatting StemVolume_m3_ha TOESTAND per periode

```{r}
results.toestand <- My.ParametersMB(
  Data = df20, VariableName = "StemVolume_m3_ha",
  GLMERModel = Model.lmer_20_0, Type = "toestand"
)

print(get_lmer_output(Model.lmer_20_0))
# results.toestand
results.toestand$Periode <- as.factor(results.toestand$Periode)

result_mm_V <- results.toestand
```


### Schatting StemVolume_m3_ha VERSCHIL tussen de twee periodes 

```{r}

results.verschil <- My.ParametersMB(Data = df20, VariableName = "StemVolume_m3_ha", GLMERModel = Model.lmer_20, Type = "verschil")

print(get_lmer_output(Model.lmer_20))
# results.verschil

result_mm_V_diff <- results.verschil
```

### Aanmaak modellen carbon

```{r}
df20 %>%
  ggplot() + 
  geom_point(aes(x = StemVolume_m3_ha, y = Carbon_t_ha,
                 colour = fPeriode),
             alpha = 0.2)
```


```{r}

# StemVolume_m3_ha : hierin Weight al verrekend -- weight = 1 zetten?
Model.lmer_20 <- lmer(formula = Carbon_t_ha ~ fPeriode + (1 | IDGroup),
                      data = df20,
                      weight = Weight)

summary(Model.lmer_20)
plot(Model.lmer_20)
df20$E <- resid(Model.lmer_20_0)
qqnorm(df20$E)
ggplot(df20, aes(x = fPeriode, y = E)) +
  geom_boxplot()

df20 %>%
  group_by(IDGroup) %>%
  mutate(gepaard = ifelse(n() == 2, "1 en 2", as.character(Periode))) %>%
  ggplot() +
  geom_point(aes(x = fitted(Model.lmer_20), 
                 y = resid(Model.lmer_20),
                 colour = gepaard,
                 shape = gepaard),
             alpha = 0.3) +
  geom_smooth(aes(x = fitted(Model.lmer_20), 
                 y = resid(Model.lmer_20))) +
  geom_hline(yintercept = 0)

ggplot(df20, aes(x = IDGroup, y = E, colour = fPeriode, group = IDGroup)) +
  geom_point() +
  geom_line() +
  labs(y = "Residual", x = "IDGepaard")

print(get_lmer_output(Model.lmer_20))
```


```{r}
# nulmodel, nodig om toestand (vs verschil) te berekenen/weg te schrijven naar db
Model.lmer_20_0 <- lmer(Carbon_t_ha ~ 0 + fPeriode + (1 | IDGroup),
  data = df20,
  weight = Weight
)
summary(Model.lmer_20_0)
plot(Model.lmer_20_0)

df20$E <- resid(Model.lmer_20_0)
qqnorm(df20$E)
ggplot(df20, aes(x = fPeriode, y = E)) +
  geom_boxplot()

ggplot(df20, aes(x = IDGroup, y = E, colour = fPeriode, group = IDGroup)) +
  geom_point() +
  geom_line() +
  labs(y = "Residual", x = "IDGepaard")
```


### Schatting Carbon_t_ha TOESTAND tussen de twee periodes 

```{r}
results.toestand <- My.ParametersMB(
  Data = df20, VariableName = "Carbon_t_ha",
  GLMERModel = Model.lmer_20_0, Type = "toestand"
)

print(get_lmer_output(Model.lmer_20_0))

# results.toestand
results.toestand$Periode <- as.factor(results.toestand$Periode)

result_mm_C <- results.toestand
```

### Schatting Carbon_t_ha VERSCHIL tussen de twee periodes 

```{r }

results.verschil <- My.ParametersMB(Data = df20, VariableName = "Carbon_t_ha", GLMERModel = Model.lmer_20, Type = "verschil")

print(get_lmer_output(Model.lmer_20))
# results.verschil

result_mm_C_diff <- results.verschil
```




# Vergelijking design based - mixed models

Probleem: de resultaten tss design-based en mixed-models liggen in het geval van volume en carbon (biomassa) toch wel wat uit elkaar. 

Ik lees in het analyserapport op p120 (ivm houtvoorraad) het volgende: *"Dus de design-based schatter (of het gewone lineair model) geven misschien iets exacter het verschil in de totale houtvoorraad, terwijl de model-based schatter eerder een juistere inschatting geeft van de toename in houtvoorraad gemiddeld genomen in een plot."*

Welke methode (MM of DB) gebruiken we dan best als we een inschatting van de aangroei (van volume of van biomassa) op niveau Vlaanderen willen berekenen?

 

```{r results='hide'}
vars <- c("Periode", "MinYear", "MaxYear", "MinReeks", "MaxReeks")

result_mm <- rbind(result_mm_V, result_mm_C) %>%
  mutate(type = "M") %>%
  mutate_at(.vars = vars, factor) %>%
  rename(variabele = Variable)
colnames(result_mm) <- str_to_lower(colnames(result_mm))

result_mm_diff <- rbind(result_mm_V_diff, result_mm_C_diff)
colnames(result_mm_diff) <- str_to_lower(colnames(result_mm_diff))

result_db <- result_db %>%
  filter(variabele %in% c("StemVolume_m3_ha", "Carbon_t_ha")) %>%
  mutate(type = "D") %>%
  rename(mean = wgt.mean)
colnames(result_db) <- str_to_lower(colnames(result_db))

result_db_diff <- result_db %>%
  select(variabele, periode, mean, se, type) %>%
  pivot_wider(names_from = "periode", values_from = c("mean", "se")) %>%
  mutate(
    verschil = mean_2 - mean_1,
    verschil_se = sqrt(se_1^2 + se_2^2),
    llci = verschil - 1.96 * verschil_se,
    ulci = verschil + 1.96 * verschil_se
  )

names(result_db)
names(result_mm)
names(result_mm_diff)
```

```{r vgl_DB_MM_toestand, results='hide'}
result_db_ <- result_db %>% select(-wgt.var, -se)
vgl_toestand <- bind_rows(result_mm, result_db_)

vgl_toestand_wide <- vgl_toestand %>%
  mutate(estimate = str_c(round(mean, 1), " [", round(llci, 1), " - ", round(ulci, 1), "]")) %>%
  dplyr::select(variabele, periode, estimate, type) %>%
  spread(key = type, value = estimate, sep = "_") %>%
  rename(design_based = type_D, mixed_model = type_M) %>%
  mutate_if(is.numeric, round, 2)
```

```{r}
vgl_toestand_wide %>%
  DT::datatable(
    filter = "none", selection = "none", rownames = FALSE,
    options = list(pageLength = 5, dom = "tip")
  )
```

```{r vgl_DB_MM_verschil, results='hide'}

vgl_verschil_wide <- bind_rows(
  result_mm_diff %>%
    select(variabele = variable, verschil, llci, ulci) %>%
    mutate(type = "M"),
  result_db_diff %>%
    select(variabele, verschil, llci, ulci, type)
) %>%
  mutate(verschil = str_c(round(verschil, 1), " [", round(llci, 1), " - ", round(ulci, 1), "]")) %>%
  select(variabele, type, verschil) %>%
  pivot_wider(names_from = "type", values_from = "verschil") %>%
  rename(model_based = M, design_based = D)
```


```{r}
vgl_verschil_wide %>%
  DT::datatable(
    filter = "none", selection = "none", rownames = FALSE,
    options = list(pageLength = 5, dom = "tip")
  )
```
# Verkenning mogelijke oorzaken

## Gebruik van gewichten


### Vergelijking model met en zonder gewichten

Het gebruik van gewichten heeft weinig invloed op het resultaat.

```{r}
Model.lmer_20 <- lmer(formula = StemVolume_m3_ha ~ fPeriode + (1 | IDGroup), data = df20, weight = Weight)
Model.lmer_20_noweight <- lmer(formula = StemVolume_m3_ha ~ fPeriode + (1 | IDGroup), data = df20)

compare_models_weight <- bind_rows(
  My.ParametersMB(
    Data = df20,
    VariableName = "StemVolume_m3_ha",
    GLMERModel = Model.lmer_20,
    Type = "verschil"
  ) %>%
    mutate(model = "with weights"),
  My.ParametersMB(
    Data = df20,
    VariableName = "StemVolume_m3_ha",
    GLMERModel = Model.lmer_20_noweight,
    Type = "verschil"
  ) %>%
    mutate(model = "without weights")
) %>%
  mutate(estimate_verschil = str_c(round(Verschil, 1), " [", round(Llci, 1), " - ", round(Ulci, 1), "]")) %>%
  select(model, estimate_verschil)

compare_models_weight %>%
  datatable(rownames = FALSE)
```



### Model based analyse met WeMix


```{r, eval=FALSE}
df20$W2 <- 1

Model.WeMix_20_0 <- mix(StemVolume_m3_ha ~ fPeriode + (1 | IDGroup),
  data = df20,
  weights = c("Weight", "W2")
)

summary(Model.WeMix_20_0)
```

Een alternatief voor lme4 is het R-package [WeMix](https://american-institutes-for-research.github.io/WeMix/) dat specifiek ontworpen is voor het gebruiken van gewichten voor steekproefeenheden.

Het geeft onderstaande uitkomst (duurt nogal lang om model te runnen). Het verschil met de resultaten op basis van lme4 is redelijk klein.  

Variance terms:
Groups:

Fixed Effects:
            Estimate Std. Error t value
(Intercept)  207.382      2.390   86.77
fPeriode2     71.230      2.984   23.87

lnl= -32521.36 
Intraclass Correlation= 0.6593 


## Vertekening gepaarde plots


### Verschil in gemiddelde volumes per ha en C per ha

Onderstaande figuur en tabel tonen aan dat:

+ de gemiddelde volumes per ha voor beide periodes hoger licht bij gepaarde plots dan bij niet gepaarde plots;
+ de toename in volume per ha (verschil tussen gemiddeldes voor beide periodes) groter is bij gepaarde plots dan bij niet gepaarde plots.

Hetzelfde geldt voor ton C per ha.

```{r}
df20_paired <- df20 %>%
  select(IDPlots, IDGroup, Reeks, Year, Periode, Weight, StemVolume_m3_ha, Carbon_t_ha) %>%
  group_by(IDPlots) %>%
  mutate(paired = (n_distinct(IDGroup) == 1) &
    (n_distinct(Periode) == 2)) %>%
  ungroup()

df20_paired %>%
  pivot_longer(cols = c("StemVolume_m3_ha", "Carbon_t_ha"), names_to = "variable", values_to = "value") %>%
  mutate(
    Periode = as.factor(Periode),
    paired_fig = ifelse(paired, "gepaarde plot", "niet gepaarde plot")
  ) %>%
  ggplot(aes(x = Periode, y = value)) +
  stat_summary(fun.data = "mean_cl_boot", alpha = 0.8) +
  facet_grid(variable ~ paired_fig, scales = "free")
```


```{r}


df20_paired <- df20_paired %>%
  mutate(
    gepaard = ifelse(paired, "gepaarde_plot", "niet_gepaarde_plot"),
    gepaard = factor(gepaard)
  ) %>%
  as.data.frame()

p1_paired <- My.WgtParEstimation(df20_paired,
  UseStrata = c(TRUE, TRUE),
  Strata = c("gepaard", "gepaard"),
  VariableName = c("StemVolume_m3_ha", "Carbon_t_ha"),
  Periode = 1
)

p2_paired <- My.WgtParEstimation(df20_paired,
  UseStrata = c(TRUE, TRUE),
  Strata = c("gepaard", "gepaard"),
  VariableName = c("StemVolume_m3_ha", "Carbon_t_ha"),
  Periode = 2
)

p1 <- My.WgtParEstimation(df20_paired,
  VariableName = c("StemVolume_m3_ha", "Carbon_t_ha"),
  Periode = 1
)

p2 <- My.WgtParEstimation(df20_paired,
  VariableName = c("StemVolume_m3_ha", "Carbon_t_ha"),
  Periode = 2
)

result_db_paired <- bind_rows(
  p1_paired,
  p2_paired,
  p1,
  p2
) %>%
  mutate(stratumNaam = ifelse(stratumNaam == "", "alle_plots", stratumNaam))


colnames(result_db_paired) <- str_to_lower(colnames(result_db_paired))

result_db_diff <- result_db_paired %>%
  select(variabele, stratumnaam, periode, wgt.mean, se) %>%
  pivot_wider(names_from = "periode", values_from = c("wgt.mean", "se")) %>%
  mutate(
    verschil = wgt.mean_2 - wgt.mean_1,
    verschil_se = sqrt(se_1^2 + se_2^2),
    llci = verschil - 1.96 * verschil_se,
    ulci = verschil + 1.96 * verschil_se,
    verschil_estimate = str_c(round(verschil, 2), " [", round(llci, 2), " - ", round(ulci, 2), "]")
  ) %>%
  arrange(variabele)


result_db_diff %>%
  select(variabele, stratumnaam, verschil_estimate) %>%
  datatable(rownames = FALSE)
```




### Schatting gemiddelde verschil per plot op basis van gepaarde plots

We vergelijken hier de design-based en model-based schatting van het gemiddelde verschil per plot op basis de gepaarde plots.



```{r}

verschil_paired <- df20_paired %>%
  filter(paired) %>%
  select(-Reeks, -Year) %>%
  pivot_longer(cols = c("StemVolume_m3_ha", "Carbon_t_ha"), names_to = "variable", values_to = "value") %>%
  pivot_wider(names_from = c("Periode"), values_from = c("value", "Weight")) %>%
  mutate(verschil = value_2 - value_1)

verschil_paired %>%
  ggplot(aes(x = verschil)) +
  geom_histogram() +
  facet_wrap(~variable, scales = "free_x")
```

De gemiddelde verschillen in onderstaande tabel komen overeen met deze in de vorige tabel (verschil in gemiddelde toestand), maar de betrouwbaarheidsintervallen zijn smaller (wat te verwachten is want we houden rekning met de gepaardheid van de plots).  

```{r}
mean_verschil_paired <- verschil_paired %>%
  group_by(variable) %>%
  summarise(
    mean_verschil_plot = sum(verschil * Weight_2) / sum(Weight_2),
    var = var(verschil),
    n = n_distinct(IDPlots)
  ) %>%
  ungroup() %>%
  mutate(
    se = sqrt(var) / sqrt(n),
    llci = mean_verschil_plot - 1.96 * se,
    ulci = mean_verschil_plot + 1.96 * se,
    mean_verschil_estimate = str_c(round(mean_verschil_plot, 2), " [", round(llci, 2), " - ", round(ulci, 2), "]")
  )


mean_verschil_paired %>%
  select(variable, mean_verschil_estimate) %>%
  arrange(variable) %>%
  datatable(
    rownames = FALSE,
    caption = "Design-based schatting van gemiddelde verschil op plotniveau voor de gepaarde plots"
  )
```

De model-based schatting voor de gepaarde plots geven hier wel een goede overeenkomst met de design-based schatting.

```{r }

df20_paired_plots <- df20_paired %>%
  filter(paired) %>%
  mutate(fPeriode = factor(Periode))

Model.lmer_vol_paired <- lmer(
  formula = StemVolume_m3_ha ~ fPeriode + (1 | IDGroup),
  data = df20_paired_plots,
  weight = Weight
)

Model.lmer_c_paired <- lmer(
  formula = Carbon_t_ha ~ fPeriode + (1 | IDGroup),
  data = df20_paired_plots,
  weight = Weight
)

# summary(Model.lmer_vol_paired)
# summary(Model.lmer_c_paired)

verschil_vol_paired <- My.ParametersMB(
  Data = df20_paired_plots,
  VariableName = "StemVolume_m3_ha",
  GLMERModel = Model.lmer_vol_paired,
  Type = "verschil"
)

verschil_c_paired <- My.ParametersMB(
  Data = df20_paired_plots,
  VariableName = "Carbon_t_ha",
  GLMERModel = Model.lmer_c_paired,
  Type = "verschil"
)

verschil_paired <- bind_rows(
  verschil_vol_paired,
  verschil_c_paired
)

colnames(verschil_paired) <- str_to_lower(colnames(verschil_paired))

verschil_paired %>%
  mutate(verschil_estimate = str_c(round(verschil, 2), " [", round(llci, 2), " - ", round(ulci, 2), "]")) %>%
  select(variable, verschil_estimate) %>%
  arrange(variable) %>%
  datatable(
    rownames = FALSE,
    caption = "Schatting van verschil op basis van mixed model met enkel gepaarde plots"
  )
```
### Vergelijk random effects tussen gepaarde en niet gepaarde plots

```{r}
df20_all_plots <- df20_paired %>%
  mutate(fPeriode = factor(Periode))

Model.lmer_vol_paired <- lmer(
  formula = StemVolume_m3_ha ~ fPeriode + (1 | IDGroup),
  data = df20_all_plots,
  weight = Weight
)

random_intercept <- (ranef(Model.lmer_vol_paired))$IDGroup %>%
  rownames_to_column(var = "IDGroup") %>%
  rename(u = "(Intercept)")

df20_all_plots <- df20_all_plots %>%
  left_join(random_intercept, by = "IDGroup") %>%
  mutate(
    resid = resid(Model.lmer_vol_paired),
    fitted = fitted(Model.lmer_vol_paired),
    intercept = fixef(Model.lmer_vol_paired)[1],
    fperiode2 = fixef(Model.lmer_vol_paired)[2]
  )
```


```{r}

df20_all_plots %>%
  ggplot(aes(y = u, x = gepaard)) +
  geom_boxplot() +
  facet_wrap(~Periode)
```

```{r}
df20_all_plots %>%
  ggplot(aes(y = resid, x = gepaard)) +
  geom_boxplot() +
  facet_wrap(~Periode)
```

# Simulatie

Op basis van de gegevens van de VBI simuleren we verschillende datasets. 
Voor de simulatie baseren we ons op de variantie en covarianties tussen de verschillende periodes voor gepaarde en niet gepaarde plots.

```{r}
correlation_paired <- df20_paired %>%
  group_by(IDPlots) %>%
  filter(n() >= 2) %>%
  ungroup() %>%
  dplyr::select(-Reeks, -Year, -IDGroup) %>%
  pivot_longer(cols = c("StemVolume_m3_ha", "Carbon_t_ha"), names_to = "variable", values_to = "value") %>%
  pivot_wider(names_from = c("Periode"), values_from = c("value", "Weight"))


correlation_paired %>%
  ggplot(aes(x = value_1, y = value_2)) +
  geom_point(alpha = 0.2) +
  facet_grid(variable ~ paired)




correlation_paired_summary <- correlation_paired %>%
  group_by(paired, variable) %>%
  summarise(
    cor_12 = round(cor(value_1, value_2), 2),
    cov_12 = round(cov(value_1, value_2), 2),
    var_1 = round(var(value_1), 1),
    var_2 = round(var(value_2), 1)
  ) %>%
  ungroup()

correlation_paired_summary %>%
  datatable(rownames = FALSE)
```
We vergelijken drie scenario's.

## Sceanrio 1

+ Zelfde gemiddelde en variantie voor gepaarde en niet gepaarde plots
  + 1000 plots waarvan de helft gepaard
  + gemiddelde volume periode 1 = 225 m³/ha
  + gemiddelde volume periode 1 = 275 m³/ha
  + covariantie gepaard plots = 14000
  + variantie gepaarde plots = 20000
  + covariantie niet gepaard plots = 7000
  + variantie niet gepaard plots = 20000


```{r}
mean_vol_1 <- 225
mean_vol_2 <- 275
cov_gepaard <- 14000
var_gepaard <- 20000
cov_nt_gepaard <- 7000
var_nt_gepaard <- 20000


# create the variance covariance matrix
sigma_gepaard <- rbind(c(var_gepaard, cov_gepaard), c(cov_gepaard, var_gepaard))
# create the mean vector
mu <- c(mean_vol_1, mean_vol_2)

sim_data_paired <- data.frame(
  plot_id = 1:500,
  paired = TRUE
)

vol_sim_paired <- mvrnorm(n = nrow(sim_data_paired), mu = mu, Sigma = sigma_gepaard) %>%
  as.data.frame()

sim_data_paired <- sim_data_paired %>%
  bind_cols(vol_sim_paired)

sigma_nt_gepaard <- rbind(c(var_nt_gepaard, cov_nt_gepaard), c(cov_nt_gepaard, var_nt_gepaard))
# create the mean vector

sim_data_nt_gepaard <- data.frame(
  plot_id = 1:500,
  paired = FALSE
)

vol_sim_nt_gepaard <- mvrnorm(n = nrow(sim_data_nt_gepaard), mu = mu, Sigma = sigma_nt_gepaard) %>%
  as.data.frame()

sim_data_nt_gepaard <- sim_data_nt_gepaard %>%
  bind_cols(vol_sim_nt_gepaard)

sim_data <- bind_rows(sim_data_nt_gepaard, sim_data_paired) %>%
  # mutate(V1 = ifelse(V1 < 0, 0, V1),
  #        V2 = ifelse(V2 < 0, 0, V2)) %>%
  pivot_longer(cols = c("V1", "V2"), names_to = "Periode", values_to = "volume_ha") %>%
  mutate(
    Periode = ifelse(Periode == "V1", "1", "2"),
    fPeriode = factor(Periode),
    group_id = ifelse(paired, str_c(plot_id, "_1"),
      str_c(plot_id, "_", Periode)
    ),
    Reeks = 1,
    Year = 1,
    IDPlots = plot_id,
    Weight = 1
  )

check <- sim_data %>%
  group_by(Periode) %>%
  summarise(mean = mean(volume_ha)) %>%
  ungroup()
```

```{r}
model_sim_toestand <- lmer(
  formula = volume_ha ~ 0 + fPeriode + (1 | group_id),
  data = sim_data
)

model_sim_verschil <- lmer(
  formula = volume_ha ~ fPeriode + (1 | group_id),
  data = sim_data
)

result_toestand_M <- My.ParametersMB(Data = sim_data, VariableName = "volume_ha", GLMERModel = model_sim_toestand, Type = "toestand") %>%
  mutate(type = "model-based") %>%
  dplyr::select(type, periode = Periode, variable = Variable, mean = Mean, llci = Llci, ulci = Ulci)

result_toestand_D <- bind_rows(
  My.WgtParEstimation(Data = sim_data, VariableName = "volume_ha", Periode = 1),
  My.WgtParEstimation(Data = sim_data, VariableName = "volume_ha", Periode = 2)
) %>%
  mutate(
    type = "design-based",
    periode = as.character(periode)
  ) %>%
  rename(variable = variabele, mean = wgt.mean)
```

Onderstaande resultaten tonen dat de model-based en designed-based schattingen zeer gelijkaardig zijn.  

```{r}
bind_rows(
  result_toestand_M,
  result_toestand_D
) %>%
  mutate(estimate = str_c(round(mean, 1), " [", round(llci, 1), " - ", round(ulci, 1), "]")) %>%
  dplyr::select(type, periode, variable, estimate) %>%
  datatable(rownames = FALSE)
```


## Sceanrio 2

Dit scenario komt overeen met de situatie van de Vlaamse bosinventarisatie:

+ Hogere gemiddelde volumes en grotere toename in volume voor gepaarde plots in vergelijking met niet gepaarde plots
  + 1000 plots waarvan de helft gepaard
  + gemiddelde volume gepaarde plots periode 1 = 225 m³/ha
  + gemiddelde volume gepaarde plots periode 2 = 275 m³/ha
  + gemiddelde volume niet gepaarde plots periode 1 = 175 m³/ha
  + gemiddelde volume niet gepaarde plots periode 2 = 200 m³/ha
  + covariantie gepaard plots = 14000
  + variantie gepaarde plots = 20000
  + covariantie niet gepaard plots = 7000
  + variantie niet gepaard plots = 20000
  
```{r}
kans_gepaard <- 0.5
mean_vol_1_gepaard <- 225
mean_vol_2_gepaard <- 275
mean_vol_1_nt_gepaard <- 175
mean_vol_2_nt_gepaard <- 200
cov_gepaard <- 14000
var_gepaard <- 20000
cov_nt_gepaard <- 7000
var_nt_gepaard <- 20000


# create the variance covariance matrix
sigma_gepaard <- rbind(c(var_gepaard, cov_gepaard), c(cov_gepaard, var_gepaard))
# create the mean vector
mu_gepaard <- c(mean_vol_1_gepaard, mean_vol_2_gepaard)
# generate the multivariate normal distribution

sim_data_paired <- data.frame(
  plot_id = 1:500,
  paired = TRUE
)

vol_sim_paired <- mvrnorm(n = nrow(sim_data_paired), mu = mu_gepaard, Sigma = sigma_gepaard) %>%
  as.data.frame()

sim_data_paired <- sim_data_paired %>%
  bind_cols(vol_sim_paired)

sigma_nt_gepaard <- rbind(c(var_nt_gepaard, cov_nt_gepaard), c(cov_nt_gepaard, var_nt_gepaard))
# create the mean vector

mu_nt_gepaard <- c(mean_vol_1_nt_gepaard, mean_vol_2_nt_gepaard)

sim_data_nt_gepaard <- data.frame(
  plot_id = 1:500,
  paired = FALSE
)

vol_sim_nt_gepaard <- mvrnorm(n = nrow(sim_data_nt_gepaard), mu = mu_nt_gepaard, Sigma = sigma_nt_gepaard) %>%
  as.data.frame()

sim_data_nt_gepaard <- sim_data_nt_gepaard %>%
  bind_cols(vol_sim_nt_gepaard)

sim_data <- bind_rows(sim_data_nt_gepaard, sim_data_paired) %>%
  # mutate(V1 = ifelse(V1 < 0, 0, V1),
  #        V2 = ifelse(V2 < 0, 0, V2)) %>%
  pivot_longer(cols = c("V1", "V2"), names_to = "Periode", values_to = "volume_ha") %>%
  mutate(
    Periode = ifelse(Periode == "V1", "1", "2"),
    fPeriode = factor(Periode),
    group_id = ifelse(paired, str_c(plot_id, "_1"),
      str_c(plot_id, "_", Periode)
    ),
    Reeks = 1,
    Year = 1,
    IDPlots = plot_id,
    Weight = 1
  )

check <- sim_data %>%
  group_by(Periode) %>%
  summarise(mean = mean(volume_ha)) %>%
  ungroup()
```

```{r}
model_sim_toestand <- lmer(
  formula = volume_ha ~ 0 + fPeriode + (1 | group_id),
  data = sim_data
)

model_sim_verschil <- lmer(
  formula = volume_ha ~ fPeriode + (1 | group_id),
  data = sim_data
)

result_toestand_M <- My.ParametersMB(Data = sim_data, VariableName = "volume_ha", GLMERModel = model_sim_toestand, Type = "toestand") %>%
  mutate(type = "model-based") %>%
  dplyr::select(type, periode = Periode, variable = Variable, mean = Mean, llci = Llci, ulci = Ulci)

result_toestand_D <- bind_rows(
  My.WgtParEstimation(Data = sim_data, VariableName = "volume_ha", Periode = 1),
  My.WgtParEstimation(Data = sim_data, VariableName = "volume_ha", Periode = 2)
) %>%
  mutate(
    type = "design-based",
    periode = as.character(periode)
  ) %>%
  rename(variable = variabele, mean = wgt.mean)
```

Net zoals bij de VBI zien we dat de model-based schatting het volume in de eerste periode sterk onderschat.

```{r}
bind_rows(
  result_toestand_M,
  result_toestand_D
) %>%
  mutate(estimate = str_c(round(mean, 1), " [", round(llci, 1), " - ", round(ulci, 1), "]")) %>%
  dplyr::select(type, periode, variable, estimate) %>%
  datatable(rownames = FALSE)
```

## Sceanrio 3

+ Hogere gemiddelde volumes voor gepaarde plots maar gelijke toename in vergelijking met niet gepaarde plots
  + 1000 plots waarvan de helft gepaard
  + gemiddelde volume gepaarde plots periode 1 = 225 m³/ha
  + gemiddelde volume gepaarde plots periode 2 = 275 m³/ha
  + gemiddelde volume niet gepaarde plots periode 1 = 175 m³/ha
  + gemiddelde volume niet gepaarde plots periode 2 = 225 m³/ha
  + covariantie gepaard plots = 14000
  + variantie gepaarde plots = 20000
  + covariantie niet gepaard plots = 7000
  + variantie niet gepaard plots = 20000
  
```{r}
kans_gepaard <- 0.5
mean_vol_1_gepaard <- 225
mean_vol_2_gepaard <- 275
mean_vol_1_nt_gepaard <- 175
mean_vol_2_nt_gepaard <- 225
cov_gepaard <- 14000
var_gepaard <- 20000
cov_nt_gepaard <- 7000
var_nt_gepaard <- 20000


# create the variance covariance matrix
sigma_gepaard <- rbind(c(var_gepaard, cov_gepaard), c(cov_gepaard, var_gepaard))
# create the mean vector
mu_gepaard <- c(mean_vol_1_gepaard, mean_vol_2_gepaard)
# generate the multivariate normal distribution

sim_data_paired <- data.frame(
  plot_id = 1:500,
  paired = TRUE
)

vol_sim_paired <- mvrnorm(n = nrow(sim_data_paired), mu = mu_gepaard, Sigma = sigma_gepaard) %>%
  as.data.frame()

sim_data_paired <- sim_data_paired %>%
  bind_cols(vol_sim_paired)

sigma_nt_gepaard <- rbind(c(var_nt_gepaard, cov_nt_gepaard), c(cov_nt_gepaard, var_nt_gepaard))
# create the mean vector

mu_nt_gepaard <- c(mean_vol_1_nt_gepaard, mean_vol_2_nt_gepaard)

sim_data_nt_gepaard <- data.frame(
  plot_id = 1:500,
  paired = FALSE
)

vol_sim_nt_gepaard <- mvrnorm(n = nrow(sim_data_nt_gepaard), mu = mu_nt_gepaard, Sigma = sigma_nt_gepaard) %>%
  as.data.frame()

sim_data_nt_gepaard <- sim_data_nt_gepaard %>%
  bind_cols(vol_sim_nt_gepaard)

sim_data <- bind_rows(sim_data_nt_gepaard, sim_data_paired) %>%
  # mutate(V1 = ifelse(V1 < 0, 0, V1),
  # V2 = ifelse(V2 < 0, 0, V2)) %>%
  pivot_longer(cols = c("V1", "V2"), names_to = "Periode", values_to = "volume_ha") %>%
  mutate(
    Periode = ifelse(Periode == "V1", "1", "2"),
    fPeriode = factor(Periode),
    group_id = ifelse(paired, str_c(plot_id, "_1"),
      str_c(plot_id, "_", Periode)
    ),
    Reeks = 1,
    Year = 1,
    IDPlots = plot_id,
    Weight = 1
  )

check <- sim_data %>%
  group_by(Periode) %>%
  summarise(mean = mean(volume_ha)) %>%
  ungroup()
```

```{r}
model_sim_toestand <- lmer(
  formula = volume_ha ~ 0 + fPeriode + (1 | group_id),
  data = sim_data
)

model_sim_verschil <- lmer(
  formula = volume_ha ~ fPeriode + (1 | group_id),
  data = sim_data
)

result_toestand_M <- My.ParametersMB(Data = sim_data, VariableName = "volume_ha", GLMERModel = model_sim_toestand, Type = "toestand") %>%
  mutate(type = "model-based") %>%
  dplyr::select(type, periode = Periode, variable = Variable, mean = Mean, llci = Llci, ulci = Ulci)

result_toestand_D <- bind_rows(
  My.WgtParEstimation(Data = sim_data, VariableName = "volume_ha", Periode = 1),
  My.WgtParEstimation(Data = sim_data, VariableName = "volume_ha", Periode = 2)
) %>%
  mutate(
    type = "design-based",
    periode = as.character(periode)
  ) %>%
  rename(variable = variabele, mean = wgt.mean)
```

Ook hier geeft de model-based benadering een onderschatting van de toestand in de eerste periode.

```{r}
bind_rows(
  result_toestand_M,
  result_toestand_D
) %>%
  mutate(estimate = str_c(round(mean, 1), " [", round(llci, 1), " - ", round(ulci, 1), "]")) %>%
  dplyr::select(type, periode, variable, estimate) %>%
  datatable(rownames = FALSE)
```
# Conclusies

+ Design-based schattingen van de toestand zijn steeds onvertekend. Het geschatte verschil tussen twee periodes zal echter een lagere precisie hebben als dit gebaseerd is op het verschil tussen de gemiddeldes per periode. Dit komt omdat we dan geen rekening houden met de gepaardheid tussen de plots.

+ Model-based schattingen van toestand en verschil op basis van een mixed model leidt tot vertekening als de gemiddelde volumes en/of de toename in volume sterk verschillende is in gepaarde en niet-gepaarde plots. 

+ Model-based schattingen kunnen onvertekende en preciezere schattingen geven van het verschil tussen periodes: 
  + Wanneer de dataset enkel uit gepaarde plots bestaan, 
  + of wanneer de gemiddeldes en de toename tussen de periodes niet sterk verschillen voor gepaarde en niet gepaarde plots
